package service

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"math"
	"sort"
	"strings"
	"time"

	"github.com/eko/gocache/lib/v4/store"
	"github.com/google/uuid"
	"github.com/nurdsoft/redesign-grp-trust-portal-api/internal/rapid7"
	remediationEntities "github.com/nurdsoft/redesign-grp-trust-portal-api/internal/remediation/entities"
	"github.com/nurdsoft/redesign-grp-trust-portal-api/internal/vulnerability/entities"
	"github.com/nurdsoft/redesign-grp-trust-portal-api/shared/cache"
	"github.com/pkg/errors"
)

type Service interface {
	GetTopRemediationTasks(ctx context.Context, companyUuid, userUuid *uuid.UUID) ([]*entities.TopRemediation, error)
	GetVulnerabilityStats(ctx context.Context, companyUuid, userUuid *uuid.UUID) (*entities.VulnerabilityStats, error)
	GetPenetrationTopRemediationTasks(ctx context.Context, companyUuid, userUuid *uuid.UUID) ([]*entities.TopRemediation, error)
	GetPenetrationStats(ctx context.Context, companyUuid, userUuid *uuid.UUID) (*entities.VulnerabilityStats, error)
}

// New service for user.
func New(rapid7Client rapid7.Client, cacheClient cache.Client) Service {
	svc := &service{rapid7Client, cacheClient}

	return svc
}

type service struct {
	rapid7Client rapid7.Client
	cacheClient  cache.Client
}

func (s *service) GetPenetrationTopRemediationTasks(ctx context.Context, companyUuid, userUuid *uuid.UUID) ([]*entities.TopRemediation, error) {
	return s.getTopRemediationTasks(ctx, companyUuid, userUuid, "pen")
}

func (s *service) GetPenetrationStats(ctx context.Context, companyUuid, userUuid *uuid.UUID) (*entities.VulnerabilityStats, error) {
	return s.getStats(ctx, companyUuid, userUuid, "pen")
}

func (s *service) GetTopRemediationTasks(ctx context.Context, companyUuid, userUuid *uuid.UUID) ([]*entities.TopRemediation, error) {
	return s.getTopRemediationTasks(ctx, companyUuid, userUuid, "vul")
}

func (s *service) GetVulnerabilityStats(ctx context.Context, companyUuid, userUuid *uuid.UUID) (*entities.VulnerabilityStats, error) {
	return s.getStats(ctx, companyUuid, userUuid, "vul")
}

func getDiffInPercentage(prevValue, lastValue float64) float64 {
	var per, diff float64
	diff = prevValue - lastValue
	if diff < 0.0 {
		increase := lastValue - prevValue
		per = (increase / prevValue) * 100
	} else if diff > 0 {
		decrease := prevValue - lastValue
		per = ((decrease / prevValue) * 100) * -1
	}

	return math.Round(per*100) / 100
}

func (s *service) getWithCache(ctx context.Context, path string, out any) error {
	val, err := s.cacheClient.Get(ctx, path)
	if err != nil {
		if err.Error() != store.NOT_FOUND_ERR {
			return errors.WithMessage(err, "cache error")
		}
	}
	if val != "" {
		return json.Unmarshal([]byte(val), out)
	}
	return nil
}

func (s *service) getStats(ctx context.Context, companyUuid, userUuid *uuid.UUID, testType string) (*entities.VulnerabilityStats, error) {
	siteIds, err := s.rapid7Client.GetSiteIds(ctx, *companyUuid, testType)
	if err != nil {
		return nil, err
	}

	catchPath := fmt.Sprintf("%s-%s", "getStats", strings.Trim(strings.Join(strings.Fields(fmt.Sprint(siteIds)), ","), "[]"))
	log.Printf("getStats catch path: %+v", catchPath)
	var data *entities.VulnerabilityStats

	err = s.getWithCache(ctx, catchPath, &data)
	if err != nil {
		return nil, err
	}

	if data != nil {
		return data, nil
	}

	ln, err := s.rapid7Client.GetLastAndNextVulnerabilityScan(ctx, siteIds)
	if err != nil {
		return nil, err
	}

	vscbis, err := s.rapid7Client.GetVulnerabilitySeverityCountsByInterval(ctx, siteIds)
	if err != nil {
		return nil, err
	}

	siteCounts, err := s.rapid7Client.GetFactSiteCountsBySiteId(ctx, siteIds)
	if err != nil {
		return nil, err
	}

	criticalStats := make([]*entities.Stats, 0)
	totalStats := make([]*entities.Stats, 0)
	var criticalTrendMap, totalTrendMap map[time.Time]int
	criticalTrendMap = make(map[time.Time]int)
	totalTrendMap = make(map[time.Time]int)

	for _, v := range vscbis {
		if v.Severity == "Critical" {
			criticalTrendMap[v.Date] = v.Count
		}
		totalTrendMap[v.Date] = totalTrendMap[v.Date] + v.Count
	}

	for k, v := range criticalTrendMap {
		stats := &entities.Stats{
			Date:  k,
			Value: v,
		}
		criticalStats = append(criticalStats, stats)
	}
	for k, v := range totalTrendMap {
		stats := &entities.Stats{
			Date:  k,
			Value: v,
		}
		totalStats = append(totalStats, stats)
	}

	sort.Slice(criticalStats, func(i, j int) bool {
		return criticalStats[i].Date.Before(criticalStats[j].Date)
	})

	sort.Slice(totalStats, func(i, j int) bool {
		return totalStats[i].Date.Before(totalStats[j].Date)
	})

	var criticalPerformance, totalPerformance float64

	if len(criticalStats) > 1 {
		criticalPerformance = getDiffInPercentage(float64(criticalStats[len(criticalStats)-2].Value), float64(criticalStats[len(criticalStats)-1].Value))
	}

	if len(totalStats) > 1 {
		totalPerformance = getDiffInPercentage(float64(totalStats[len(totalStats)-2].Value), float64(totalStats[len(totalStats)-1].Value))
	}

	var criticalCurrent, totalCurrent int
	if len(criticalStats) > 0 {
		criticalCurrent = criticalStats[len(criticalStats)-1].Value
	}

	if len(totalStats) > 0 {
		totalCurrent = totalStats[len(totalStats)-1].Value
	}

	data = &entities.VulnerabilityStats{}
	data.Scans = &entities.Scan{
		LastVulnerabilityScan: ln.LastVulnerabilityScan,
		NextVulnerabilityScan: ln.NextVulnerabilityScan,
	}
	data.Critical = &entities.Critical{
		Current:     criticalCurrent,
		Performance: criticalPerformance,
		Stats:       criticalStats,
	}
	data.Total = &entities.Total{
		Current:     totalCurrent,
		Performance: totalPerformance,
		Stats:       totalStats,
	}
	data.Count = &entities.Count{
		Critical: siteCounts.CriticalVulnerabilities,
		Severe:   siteCounts.SevereVulnerabilities,
		Moderate: siteCounts.ModerateVulnerabilities,
		Total:    siteCounts.Vulnerabilities,
	}

	dataStr, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	err = s.cacheClient.Set(ctx, catchPath, string(dataStr))
	if err != nil {
		return nil, err
	}

	return data, nil
}

func (s *service) getTopRemediationTasks(ctx context.Context, companyUuid, userUuid *uuid.UUID, testType string) ([]*entities.TopRemediation, error) {
	//siteName := s.rapid7Client.GetDefaultSiteName(ctx)

	//get site_id by site name
	siteIds, err := s.rapid7Client.GetSiteIds(ctx, *companyUuid, testType)
	if err != nil {
		return nil, err
	}

	catchPath := fmt.Sprintf("%s-%s", "getTopRemediationTasks", strings.Trim(strings.Join(strings.Fields(fmt.Sprint(siteIds)), ","), "[]"))
	log.Printf("GetTopRemediationTasks Catch path: %+v", catchPath)
	var res []*entities.TopRemediation

	err = s.getWithCache(ctx, catchPath, &res)
	if err != nil {
		return nil, err
	}

	if res != nil {
		return res, nil
	}

	tr, err := s.rapid7Client.GetTopRemediationTasks(ctx, siteIds)
	if err != nil {
		return nil, err
	}

	res = make([]*entities.TopRemediation, 0)

	for _, r := range tr {
		rd := remediationEntities.RemediationDetail{}
		rd.RemediationName = r.RemediationName.String
		rd.RemediationLink = r.RemediationLink.String
		rd.IssueDescription = r.IssueDescription.String

		t := &entities.TopRemediation{
			RiskScore: r.RiskScore,
			Title:     r.RemediationName.String,
		}

		var steps []string
		solSteps, err := s.rapid7Client.GetSolutionSupercedenceSteps(ctx, r.SolutionId)
		if err != nil {
			return nil, err
		}
		steps = append(steps, r.SolutionStep.String)
		steps = append(steps, solSteps...)

		rd.Recommendations = steps
		t.RemediationDetail = rd
		res = append(res, t)
	}

	resStr, err := json.Marshal(res)
	if err != nil {
		return nil, err
	}

	err = s.cacheClient.Set(ctx, catchPath, string(resStr))
	if err != nil {
		return nil, err
	}

	return res, nil
}
